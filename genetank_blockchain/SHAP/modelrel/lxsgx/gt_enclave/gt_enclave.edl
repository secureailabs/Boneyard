enclave {
    //from "sgx_tkey_exchange.edl" import *;
	from "sgx_tae_service.edl" import *;
	trusted {
        public sgx_status_t sgx_ra_get_ga(sgx_ra_context_t context,
            [out] sgx_ec256_public_t *g_a);

        public sgx_status_t sgx_ra_proc_msg2_trusted(sgx_ra_context_t context,
            [in]const sgx_ra_msg2_t *p_msg2, /*copy msg2 except quote into enclave */
            [in] const sgx_target_info_t *p_qe_target,
            [out] sgx_report_t *p_report,
            [out] sgx_quote_nonce_t *p_nonce);

        public sgx_status_t sgx_ra_get_msg3_trusted(sgx_ra_context_t context,
            uint32_t quote_size,
            [in]sgx_report_t* qe_report,
            [user_check]sgx_ra_msg3_t *p_msg3,
            uint32_t msg3_size);
	};

    include "sgx_key_exchange.h"
    include "sgx_trts.h"
	trusted {
		public sgx_status_t get_prediction([in, size=len] char *buffer,
		                                   size_t len,
										   [out] double *result);
	    public sgx_status_t enclave_initx(int new_enclave);
		public sgx_status_t get_report([in,size=message_size] const char * runner_addr,size_t message_size,
									   [in] sgx_target_info_t *p_target,
		                               [out]sgx_report_t *p_report);
        public sgx_status_t enclave_init_ra(int b_pse,
                                            [out] sgx_ra_context_t *p_context);
        public sgx_status_t enclave_ra_close(sgx_ra_context_t context);
        public sgx_status_t verify_att_result_mac(sgx_ra_context_t context,
                                                  [in,size=message_size] uint8_t* message, 
                                                  size_t message_size, 
                                                  [in,size=mac_size] uint8_t* mac, 
                                                  size_t mac_size);
        public sgx_status_t put_secret_data(sgx_ra_context_t context,  
                                            [in,size=secret_size] uint8_t* p_secret,
                                            uint32_t secret_size,
                                            [in,count=16] uint8_t* gcm_mac);
    };

	include "sgx_tprotected_fs.h"
	untrusted {
		void*   u_sgxprotectedfs_exclusive_file_open([in, string] const char* filename, uint8_t read_only, [out] int64_t* file_size, [out] int32_t* error_code);
		uint8_t u_sgxprotectedfs_check_if_file_exists([in, string] const char* filename);
		int32_t u_sgxprotectedfs_fread_node([user_check] void* f, uint64_t node_number, [out, size=node_size] uint8_t* buffer, uint32_t node_size);
		int32_t u_sgxprotectedfs_fwrite_node([user_check] void* f, uint64_t node_number, [in, size=node_size] uint8_t* buffer, uint32_t node_size);
		int32_t u_sgxprotectedfs_fclose([user_check] void* f);
		uint8_t u_sgxprotectedfs_fflush([user_check] void* f);
		int32_t u_sgxprotectedfs_remove([in, string] const char* filename);

		void*   u_sgxprotectedfs_recovery_file_open([in, string] const char* filename);
		uint8_t u_sgxprotectedfs_fwrite_recovery_node([user_check] void* f, [in, count=data_length] uint8_t* data, uint32_t data_length);
		int32_t u_sgxprotectedfs_do_file_recovery([in, string] const char* filename, [in, string] const char* recovery_filename, uint32_t node_size);
    };

};
