/* bsplvd.f -- translated by f2c (version 20160102).
   You must link the resulting object file with libf2c:
	on Microsoft Windows system, link with libf2c.lib;
	on Linux or Unix systems, link with .../path/to/libf2c.a -lm
	or, if you install libf2c.a in a standard place, with -lf2c -lm
	-- in that order, at the end of the command line, as in
		cc *.o -lf2c -lm
	Source for libf2c is in /netlib/f2c/libf2c.zip, e.g.,

		http://www.netlib.org/f2c/libf2c.zip
*/

#include "../../include/f2c.h"

/* Table of constant values */

static integer c__1 = 1;
static integer c__2 = 2;

/* Subroutine */ int bsplvd_(doublereal *t, integer *lent, integer *k, 
	doublereal *x, integer *left, doublereal *a, doublereal *dbiatx, 
	integer *nderiv)
{
    /* System generated locals */
    integer dbiatx_dim1, dbiatx_offset, a_dim1, a_offset, i__1, i__2, i__3;

    /* Local variables */
    static integer i__, j, m, il, kp1;
    static doublereal sum;
    static integer jlow, kp1mm, mhigh, jp1mid;
    static doublereal fkp1mm, factor;
    static integer ideriv;
    extern /* Subroutine */ int bsplvb_(doublereal *, integer *, integer *, 
	    integer *, doublereal *, integer *, doublereal *);
    static integer ldummy;

/*     --------   ------ */
/*      implicit none */
/* calculates value and deriv.s of all b-splines which do not vanish at x */
/* calls bsplvb */

/* ******  i n p u t  ****** */
/*  t     the knot array, of length left+k (at least) */
/*  k     the order of the b-splines to be evaluated */
/*  x     the point at which these values are sought */
/*  left  an integer indicating the left endpoint of the interval of */
/*        interest. the  k  b-splines whose support contains the interval */
/*               (t(left), t(left+1)) */
/*        are to be considered. */
/*  a s s u m p t i o n  - - -  it is assumed that */
/*               t(left) < t(left+1) */
/*        division by zero will result otherwise (in  b s p l v b ). */
/*        also, the output is as advertised only if */
/*               t(left) <= x <= t(left+1) . */
/*  nderiv   an integer indicating that values of b-splines and their */
/*        derivatives up to but not including the  nderiv-th  are asked */
/*        for. ( nderiv  is replaced internally by the integer in (1,k) */
/*        closest to it.) */

/* ******  w o r k   a r e a  ****** */
/*  a     an array of order (k,k), to contain b-coeff.s of the derivat- */
/*        ives of a certain order of the  k  b-splines of interest. */

/* ******  o u t p u t  ****** */
/*  dbiatx   an array of order (k,nderiv). its entry  (i,m)  contains */
/*        value of  (m-1)st  derivative of  (left-k+i)-th  b-spline of */
/*        order  k  for knot sequence  t , i=m,...,k; m=1,...,nderiv. */

/* ******  m e t h o d  ****** */
/*  values at  x  of all the relevant b-splines of order k,k-1,..., */
/*  k+1-nderiv  are generated via  bsplvb  and stored temporarily */
/*  in  dbiatx .  then, the b-coeffs of the required derivatives of the */
/*  b-splines of interest are generated by differencing, each from the */
/*  preceding one of lower order, and combined with the values of b- */
/*  splines of corresponding order in  dbiatx  to produce the desired */
/*  values. */
/* Args */
/* Locals */
    /* Parameter adjustments */
    --t;
    a_dim1 = *k;
    a_offset = 1 + a_dim1;
    a -= a_offset;
    dbiatx_dim1 = *k;
    dbiatx_offset = 1 + dbiatx_dim1;
    dbiatx -= dbiatx_offset;

    /* Function Body */
/* Computing MAX */
    i__1 = min(*nderiv,*k);
    mhigh = max(i__1,1);
/*     mhigh is usually equal to nderiv. */
    kp1 = *k + 1;
    i__1 = kp1 - mhigh;
    bsplvb_(&t[1], lent, &i__1, &c__1, x, left, &dbiatx[dbiatx_offset]);
    if (mhigh == 1) {
	return 0;
    }
/*     the first column of  dbiatx  always contains the b-spline values */
/*     for the current order. these are stored in column k+1-current */
/*     order  before  bsplvb  is called to put values for the next */
/*     higher order on top of it. */
    ideriv = mhigh;
    i__1 = mhigh;
    for (m = 2; m <= i__1; ++m) {
	jp1mid = 1;
	i__2 = *k;
	for (j = ideriv; j <= i__2; ++j) {
	    dbiatx[j + ideriv * dbiatx_dim1] = dbiatx[jp1mid + dbiatx_dim1];
	    ++jp1mid;
/* L11: */
	}
	--ideriv;
	i__2 = kp1 - ideriv;
	bsplvb_(&t[1], lent, &i__2, &c__2, x, left, &dbiatx[dbiatx_offset]);
/* L15: */
    }

/*     at this point,  b(left-k+i, k+1-j)(x) is in  dbiatx(i,j) for */
/*     i=j,...,k and j=1,...,mhigh ('=' nderiv). in particular, the */
/*     first column of  dbiatx  is already in final form. to obtain cor- */
/*     responding derivatives of b-splines in subsequent columns, gene- */
/*     rate their b-repr. by differencing, then evaluate at  x. */

    jlow = 1;
    i__1 = *k;
    for (i__ = 1; i__ <= i__1; ++i__) {
	i__2 = *k;
	for (j = jlow; j <= i__2; ++j) {
	    a[j + i__ * a_dim1] = 0.;
/* L19: */
	}
	jlow = i__;
	a[i__ + i__ * a_dim1] = 1.;
/* L20: */
    }
/*     at this point, a(.,j) contains the b-coeffs for the j-th of the */
/*     k  b-splines of interest here. */

    i__1 = mhigh;
    for (m = 2; m <= i__1; ++m) {
	kp1mm = kp1 - m;
	fkp1mm = (doublereal) kp1mm;
	il = *left;
	i__ = *k;

/*        for j=1,...,k, construct b-coeffs of  (m-1)st  derivative of */
/*        b-splines from those for preceding derivative by differencing */
/*        and store again in  a(.,j) . the fact that  a(i,j) = 0  for */
/*        i < j  is used.sed. */
	i__2 = kp1mm;
	for (ldummy = 1; ldummy <= i__2; ++ldummy) {
	    factor = fkp1mm / (t[il + kp1mm] - t[il]);
/*           the assumption that t(left) < t(left+1) makes denominator */
/*           in  factor  nonzero. */
	    i__3 = i__;
	    for (j = 1; j <= i__3; ++j) {
		a[i__ + j * a_dim1] = (a[i__ + j * a_dim1] - a[i__ - 1 + j * 
			a_dim1]) * factor;
/* L24: */
	    }
	    --il;
	    --i__;
/* L25: */
	}

/*        for i=1,...,k, combine b-coeffs a(.,i) with b-spline values */
/*        stored in dbiatx(.,m) to get value of  (m-1)st  derivative of */
/*        i-th b-spline (of interest here) at  x , and store in */
/*        dbiatx(i,m). storage of this value over the value of a b-spline */
/*        of order m there is safe since the remaining b-spline derivat- */
/*        ive of the same order do not use this value due to the fact */
/*        that  a(j,i) = 0  for j < i . */
	i__2 = *k;
	for (i__ = 1; i__ <= i__2; ++i__) {
	    sum = 0.;
	    jlow = max(i__,m);
	    i__3 = *k;
	    for (j = jlow; j <= i__3; ++j) {
		sum = a[j + i__ * a_dim1] * dbiatx[j + m * dbiatx_dim1] + sum;
/* L35: */
	    }
	    dbiatx[i__ + m * dbiatx_dim1] = sum;
/* L40: */
	}
/* L45: */
    }
    return 0;
} /* bsplvd_ */

/* Subroutine */ int bsplvb_(doublereal *t, integer *lent, integer *jhigh, 
	integer *index, doublereal *x, integer *left, doublereal *biatx)
{
    /* Initialized data */

    static integer j = 1;

    /* System generated locals */
    integer i__1;

    /* Local variables */
    static integer i__, jp1;
    static doublereal term, saved, deltal[20], deltar[20];

/*      implicit none */
/*     ------------- */
/* alculates the value of all possibly nonzero b-splines at  x  of order */

/*               jout  =  dmax( jhigh , (j+1)*(index-1) ) */

/*  with knot sequence  t . */

/* ******  i n p u t  ****** */
/*  t.....knot sequence, of length  left + jout  , assumed to be nonde- */
/*        creasing. */
/*    a s s u m p t i o n  :  t(left)  <  t(left + 1) */
/*    d i v i s i o n  b y  z e r o  will result if  t(left) = t(left+1) */

/*  jhigh, */
/*  index.....integers which determine the order  jout = max(jhigh, */
/*        (j+1)*(index-1))  of the b-splines whose values at  x  are to */
/*        be returned.  index  is used to avoid recalculations when seve- */
/*        ral columns of the triangular array of b-spline values are nee- */
/*        ded (e.g., in  bvalue  or in  bsplvd ). precisely, */
/*                     if  index = 1 , */
/*        the calculation starts from scratch and the entire triangular */
/*        array of b-spline values of orders 1,2,...,jhigh  is generated */
/*        order by order , i.e., column by column . */
/*                     if  index = 2 , */
/*        only the b-spline values of order  j+1, j+2, ..., jout  are ge- */
/*        nerated, the assumption being that  biatx , j , deltal , deltar */
/*        are, on entry, as they were on exit at the previous call. */
/*           in particular, if  jhigh = 0, then  jout = j+1, i.e., just */
/*        the next column of b-spline values is generated. */

/*  w a r n i n g . . .  the restriction   jout <= jmax (= 20)  is */
/*        imposed arbitrarily by the dimension statement for  deltal and */
/*        deltar  below, but is  n o w h e r e  c h e c k e d  for . */

/*  x.....the point at which the b-splines are to be evaluated. */
/*  left.....an integer chosen (usually) so that */
/*                  t(left) <= x <= t(left+1)  . */

/* ******  o u t p u t  ****** */
/*  biatx.....array of length  jout , with  biatx(i)  containing the val- */
/*        ue at  x  of the polynomial of order  jout  which agrees with */
/*        the b-spline  b(left-jout+i,jout,t)  on the interval (t(left), */
/*        t(left+1)) . */

/* ******  m e t h o d  ****** */
/*  the recurrence relation */

/*                       x - t(i)               t(i+j+1) - x */
/*     b(i,j+1)(x)  =  ----------- b(i,j)(x) + --------------- b(i+1,j)(x) */
/*                     t(i+j)-t(i)             t(i+j+1)-t(i+1) */

/*  is used (repeatedly) to generate the */
/*  (j+1)-vector  b(left-j,j+1)(x),...,b(left,j+1)(x) */
/*  from the j-vector  b(left-j+1,j)(x),...,b(left,j)(x), */
/*  storing the new values in  biatx  over the old.  the facts that */
/*            b(i,1) = 1         if  t(i) <= x < t(i+1) */
/*  and that */
/*            b(i,j)(x) = 0  unless  t(i) <= x < t(i+j) */
/*  are used. the particular organization of the calculations follows */
/*  algorithm (8)  in chapter x of the text. */

/* Arguments */
/*     dimension     t(left+jout), biatx(jout) */
/*     ----------------------------------- */
/* current fortran standard makes it impossible to specify the length of */
/*  t  and of  biatx  precisely without the introduction of otherwise */
/*  superfluous additional arguments. */
/* Local Variables */
    /* Parameter adjustments */
    --t;
    --biatx;

    /* Function Body */

/*                                        go to (10,20), index */
    if (*index == 2) {
	goto L20;
    }
    j = 1;
    biatx[1] = 1.;
    if (j >= *jhigh) {
	return 0;
    }

L20:
    jp1 = j + 1;
    deltar[j - 1] = t[*left + j] - *x;
    deltal[j - 1] = *x - t[*left + 1 - j];
    saved = 0.;
    i__1 = j;
    for (i__ = 1; i__ <= i__1; ++i__) {
	term = biatx[i__] / (deltar[i__ - 1] + deltal[jp1 - i__ - 1]);
	biatx[i__] = saved + deltar[i__ - 1] * term;
	saved = deltal[jp1 - i__ - 1] * term;
/* L26: */
    }
    biatx[jp1] = saved;
    j = jp1;
    if (j < *jhigh) {
	goto L20;
    }
    return 0;
} /* bsplvb_ */

